# Angular Development Guidelines for E-Commerce Store

## ðŸ“‹ Angular Best Practices

### Components:

- Always use standalone components (`standalone: true`)
- Use Signals for local state management
- Prefer `input()` and `output()` over decorators
- Use `computed()` for derived state

### State Management:

- Use Signals for local component state
- Use services with `BehaviorSubject` for global state
- Use NgRx/Store for complex state (optional)

### Directives:

- Use attribute selectors with the `[es-]` prefix
- Use `HostBinding`/`HostListener` within the `host` object

### Services:

- Use `providedIn: 'root'` for singleton services
- Prefer `inject()` over constructor injection
- Organize services by responsibility

## ðŸŽ¯ Project Rules

### File Naming:

- `products-list.component.ts` âœ…
- `product-detail.component.ts` âœ…
- `products.service.ts` âœ…
- `product.model.ts` âœ…

### Component Structure:

```typescript
@Component({
  selector: 'app-example',
  standalone: true,
  imports: [CommonModule, FormsModule],
  template: `
    @if (isLoading()) {
      <div>Loading...</div>
    }
    @for (item of items(); track item.id) {
      <app-item [item]="item" />
    }
  `,
  changeDetection: ChangeDetectionStrategy.OnPush
})
```

### API Handling:

1. Show loading states
2. Handle errors gracefully
3. Implement automatic retries
4. Apply caching strategies

## ðŸ”§ AI Tools Integration

### For Gemini API:

1. Create a dedicated service for API calls
2. Store API keys in environment variables
3. Use HTTP interceptors to manage requests

### For Firebase AI Logic:

1. Use AngularFire
2. Use Cloud Functions for complex operations
3. Use Firestore for data storage

## ðŸš€ Design Patterns Applied

1. Container/Presentational Components
2. Feature-based Architecture
3. Repository Pattern for data handling
4. Facade Pattern for APIs
